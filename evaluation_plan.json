[
  {
    "task_id": 2,
    "function_code": "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res) ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == tuple(set(test_tup1) & set(test_tup2))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "set(result) == set(test_tup1) & set(test_tup2)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert set(result).issubset(set(test_tup1)) and set(result).issubset(set(test_tup2))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 3,
    "function_code": "import math\ndef is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (n > 1 and any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1)))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == (n <= 1 or any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1)))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result == (n <= 1 or any(n % i == 0 for i in range(2, int(math.sqrt(n)) + 1)))),",
        "is_testable": false
      }
    }
  },
  {
    "task_id": 4,
    "function_code": "import heapq as hq\ndef heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sorted(nums, reverse=True)[:n]",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "len(result) == n and all(x in nums for x in result) and all(x <= y for x, y in zip(sorted(result), sorted(nums))) and sorted(result, reverse=True) == sorted(hq.nlargest(n, nums), reverse=True)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert len(result) == min(n, len(nums)) and result == sorted(nums, reverse=True)[:min(n, len(nums))]",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 6,
    "function_code": "def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (x & (x - 1) == 0)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "is_Power_Of_Two(x ^ x) == result",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result) == (x != 0 and (x & (x - 1)) == 0)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 7,
    "function_code": "import re\ndef find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))",
    "postconditions": {
      "naive": {
        "postcondition_string": "`all(len(word) >= 4 for word in result)`",
        "is_testable": false
      },
      "few_shot": {
        "postcondition_string": "all(len(x) >= 4 and x.isalpha() for x in result) and all(x in text for x in result)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(len(word) >= 4 for word in result) and (result or not re.findall(r\"\\b\\w{4,}\\b\", text))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 8,
    "function_code": "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == [num ** 2 for num in nums]",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == list(map(lambda x: x ** 2, nums))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(result[i] == nums[i] ** 2 for i in range(len(nums))) if len(nums) == len(result) else False",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 9,
    "function_code": "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result >= 1 and result <= len(str) and (str == (str + str)[result:result+len(str)])",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result >= 1 and result <= len(str) and str == (str + str)[result:result+len(str)]",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert 1 <= result <= len(str)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 11,
    "function_code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == s.replace(ch, '', 1).replace(ch, '', 1) or (ch not in s and result == s)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == s.replace(ch, '', 1).replace(ch, '', 1) or (ch not in s and result == s)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (s.count(ch) - result.count(ch) <= 2)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 12,
    "function_code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sorted(M, key=sum)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(sum(result[i]) <= sum(result[j]) for i in range(len(result)) for j in range(i+1, len(result))) and len(result) == len(M) and all(any(all(x == y for x, y in zip(row, orig_row)) for orig_row in M) for row in result)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "all(sum(row1) <= sum(row2) for row1, row2 in zip(result, result[1:])) and all(all(isinstance(element, (int, float)) for element in row) for row in M)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 14,
    "function_code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (l * b * h) / 2",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == (l * b * h) / 2",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result == ((l * b * h) / 2))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 96,
    "function_code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == len([i for i in range(1, n+1) if n % i == 0])",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == len([i for i in range(1, n+1) if n % i == 0])",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert isinstance(result, int) and result >= 1, 'n > 0'",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 97,
    "function_code": "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n",
    "postconditions": {
      "naive": {
        "postcondition_string": "isinstance(result, dict) and all(isinstance(key, (int, float)) and isinstance(value, int) and value > 0 for key, value in result.items())",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(result.get(x, 0) == list1.count(x) for sublist in list1 for x in sublist) and all(x in result for sublist in list1 for x in sublist if sublist.count(x) > 0)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(isinstance(key, type(list1[0][0])) and isinstance(value, int) and value > 0 for key, value in result.items()) and len(result) == len(set([item for sublist in list1 for item in sublist]))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 98,
    "function_code": "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sum(numbers) / len(numbers)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == sum(x * total / len(numbers) for x in numbers) / len(numbers)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == (eval('*'.join(map(str, numbers))) ** (1/len(numbers))) if numbers else False",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 99,
    "function_code": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") ",
    "postconditions": {
      "naive": {
        "postcondition_string": "int(result, 2) == n",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "int(\"0b\" + result, 2) == n",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert(int(result, 2) == n)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 100,
    "function_code": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i",
    "postconditions": {
      "naive": {
        "postcondition_string": "result >= num and str(result) == str(result)[::-1]",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "str(result) == str(result)[::-1] and result > num",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert str(result) == str(result)[::-1] and result > num",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 101,
    "function_code": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sorted(arr)[k-1]",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == sorted(arr)[k-1]",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "`assert result == sorted(arr)[k-1]`",
        "is_testable": false
      }
    }
  },
  {
    "task_id": 102,
    "function_code": "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == ''.join(x.capitalize() for x in word.split('_') if x)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == ''.join(x.capitalize() for x in word.split('_') if x)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(x.isupper() or x.islower() for x in result) and result == ''.join(x.capitalize() if i != 0 else x for i, x in enumerate(word.split('_')))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 103,
    "function_code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m)) if 0 < m < n else (1 if m == 0 else 0)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m) if 0 < n and 0 <= m < n else (1 if m == 0 else 0))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert isinstance(result, int) and result >= 0, f\"Expected eulerian_num({n}, {m}) to return a non-negative integer, but got {result}\"",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 104,
    "function_code": "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n",
    "postconditions": {
      "naive": {
        "postcondition_string": "all(all(y[0] <= z[0] for y, z in zip(sublist, sublist[1:])) for sublist in result) and input_list == [tuple(x) for x in result]",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(all(y[0] <= z[0] for y, z in zip(x, x[1:])) for x in result) and len(result) == len(input_list) and all(len(x) == len(y) for x, y in zip(result, input_list))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "`all(all(x[0] <= y[0] for x, y in zip(sublist, sublist[1:])) for sublist in result)`",
        "is_testable": false
      }
    }
  },
  {
    "task_id": 105,
    "function_code": "def count(lst):   \n    return sum(lst) ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sum(lst)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == sum(lst)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert isinstance(result, (int, float)) and result == sum(lst)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 170,
    "function_code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sum(list1[m:n+1])",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == sum(list1[i] for i in range(m, n+1, 1))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == sum(list1[m:n+1])",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 171,
    "function_code": "import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == 5 * a",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == 5 * a",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == 5 * a",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 172,
    "function_code": "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sum(1 for i in range(len(s) - 2) if s[i:i+3] == 'std')",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == sum(1 for i in range(len(s) - 2) if s[i:i+3] == 'std')",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == sum(1 for i in range(len(s) - 2) if s[i:i+3] == 'std')",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 222,
    "function_code": "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) ",
    "postconditions": {
      "naive": {
        "postcondition_string": "`result == all(isinstance(ele, type(test_tuple[0])) for ele in test_tuple)`",
        "is_testable": false
      },
      "few_shot": {
        "postcondition_string": "all(isinstance(ele, type(test_tuple[0])) for ele in test_tuple) == result",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (len(test_tuple) == 0 or all(isinstance(ele, type(test_tuple[0])) for ele in test_tuple)) == result",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 223,
    "function_code": "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (arr.count(x) > n/2)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == (binary_search(arr, 0, n-1, x) != -1 and (binary_search(arr, 0, n-1, x) + n//2 <= n-1 and arr[binary_search(arr, 0, n-1, x) + n//2] == x))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "result == (arr.count(x) > n//2)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 224,
    "function_code": "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == bin(n).count('1')",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == bin(n).count('1')",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == bin(n).count('1')",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 226,
    "function_code": "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == \"\".join([str[i] for i in range(len(str)) if i % 2 == 0])",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == \"\".join([str[i] for i in range(len(str)) if i % 2 == 0])",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(result[i] == str[i*2] for i in range(len(result))) and len(result) <= len(str)//2 + len(str)%2",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 227,
    "function_code": "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == min(a, b, c)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == min(a, b, c)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result <= a) and (result <= b) and (result <= c)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 228,
    "function_code": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == ((n & (((1 << r) - 1) ^ ((1 << (l - 1)) - 1))) == 0)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == ((n & (((1 << r) - 1) ^ ((1 << (l - 1)) - 1))) == 0)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "`assert (result == ((n & (((1 << r) - 1) ^ ((1 << (l - 1)) - 1))) == 0))`",
        "is_testable": false
      }
    }
  },
  {
    "task_id": 229,
    "function_code": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr",
    "postconditions": {
      "naive": {
        "postcondition_string": "all(arr[i] < 0 for i in range(result.index(next((x for x in result if x < 0), None)))) and all(result[i] >= 0 for i in range(result.index(next((x for x in result if x < 0), None)) + result.count([x for x in result if x < 0])) if len([x for x in result if x < 0]) != 0 else True) and all(result[i] >= 0 for i in range(len(result) - result.count([x for x in result if x >= 0])) if len([x for x in result if x >= 0]) != 0 else True)",
        "is_testable": false
      },
      "few_shot": {
        "postcondition_string": "all(x >= 0 for x in arr[j:]) and all(x < 0 for x in arr[:j]) and j == sum(1 for x in arr if x < 0) and sorted(arr[j:], reverse=True) == sorted([x for x in arr if x >= 0], reverse=True) and sorted(arr[:j], reverse=True) == sorted([x for x in arr if x < 0], reverse=True) and result == arr",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(x < 0 for x in result[:sum(1 for y in arr if y < 0)]) and all(x >= 0 for x in result[sum(1 for y in arr if y < 0):])",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 278,
    "function_code": "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == next((i for i, x in enumerate(test_tup) if isinstance(x, tuple)), len(test_tup))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == next((i for i, x in enumerate(test_tup) if isinstance(x, tuple)), len(test_tup))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert 0 <= result <= len(test_tup) - 1 or (len(test_tup) == 0 and result is None)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 279,
    "function_code": "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == 4 * n * n - 3 * n",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == 4 * n * n - 3 * n",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result >= 0) and ((result == 0) or (4 * n * n - 3 * n == result))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 280,
    "function_code": "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos",
    "postconditions": {
      "naive": {
        "postcondition_string": "result[0] == (item in dlist) and (result[0] or result[1] == 0) and (not result[0] or result[1] == dlist.index(item))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result[0] == (item in dlist) and (not result[0] or result[1] == dlist.index(item))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (not result[0] and result[1] == len(dlist)) or (result[0] and dlist[result[1]] == item)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 281,
    "function_code": "def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (len(test_list) == len(set(test_list)))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == (len(test_list) == len(set(test_list)))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result == (len(test_list) == len(set(test_list)))),",
        "is_testable": false
      }
    }
  },
  {
    "task_id": 282,
    "function_code": "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)",
    "postconditions": {
      "naive": {
        "postcondition_string": "all(x - y == z for x, y, z in zip(nums1, nums2, result))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(x - y == z for x, y, z in zip(nums1, nums2, result))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(result[i] == nums1[i] - nums2[i] for i in range(len(result))) and len(result) == min(len(nums1), len(nums2))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 283,
    "function_code": "def validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == all(n.count(str(i)) <= i for i in range(10))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(all((int(d) <= n % 10**i // 10**(i-1) for d in str(n)) for i in range(1, len(str(n))+1)) for n in [n]) and all((str(n).count(str(i)) <= i for i in range(10))) == result",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(str(n).count(str(i)) <= i for i in range(10)) == result",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 284,
    "function_code": "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (len(set(list)) == 1 and (not list or list[0] == element))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == all(v == element for v in list)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == (len(set([x for x in list if x == element])) == len(list) if list else True)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 285,
    "function_code": "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (re.search('ab{2,3}', text) is not None)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == (re.search('ab{2,3}', text) is not None)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result == (re.search('ab{2,3}', text) is not None))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 286,
    "function_code": "def max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == max(max(sum(a[i%n] for i in range(j, min(n*k, j+n))) for j in range(n*k)) if any(a[i%n] for i in range(n*k)) else 0)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == max(sum(a[i%n] for i in range(j, min(n*k, j+n))) for j in range(n*k))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result <= sum(max(a, 0)) * k and result >= max(sum(a), 0)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 287,
    "function_code": "def square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sum(i**2 for i in range(1, n+1))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == int(2*n*(n+1)*(2*n+1)/6)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == sum(i**2 for i in range(1, n+1))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 410,
    "function_code": "def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val",
    "postconditions": {
      "naive": {
        "postcondition_string": "isinstance(result, int) and all(result <= i for i in listval if isinstance(i, int))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == min(i for i in listval if isinstance(i, int))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (all(isinstance(i, int) and i >= result for i in listval if isinstance(i, int)) or (not any(isinstance(i, int) for i in listval) and result == min_val(listval) if listval else None))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 411,
    "function_code": "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == ''.join(x.capitalize() if x else '_' for x in word.split('_'))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == ''.join(x.capitalize() for x in word.split('_') if x)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result and result[0].islower() or (not word.startswith('_') and result and result[0].isupper())) and all(c.islower() or c.isupper() for c in result) and all(result[i].isupper() for i in range(1, len(result)) if result[i-1] not in '_')",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 412,
    "function_code": "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l",
    "postconditions": {
      "naive": {
        "postcondition_string": "all(i % 2 == 0 for i in result)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(x % 2 == 0 for x in result) and len([i for i in l if i % 2 == 0]) == len(result)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(i % 2 == 0 for i in result)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 413,
    "function_code": "def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result",
    "postconditions": {
      "naive": {
        "postcondition_string": "all(0 <= n < len(x) and result[i] == list1[i][n] for i, x in enumerate(list1))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == [x[n] for x in list1]",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "all(len(x) > n or x[n] == result[i] for i, x in enumerate(list1))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 414,
    "function_code": "def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == (set(list1) & set(list2) != set())",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == any(x in list2 for x in list1)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert (result == True) == (any(element in list2 for element in list1) or any(element in list1 for element in list2))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 415,
    "function_code": "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    ",
    "postconditions": {
      "naive": {
        "postcondition_string": "result[0] * result[1] == max(a * b for i, a in enumerate(arr) for b in arr[i+1:])",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result[0] * result[1] == max(arr[i] * arr[j] for i in range(len(arr)) for j in range(i + 1, len(arr)))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert arr[0]*arr[1] <= result[0]*result[1] if len(arr) < 2 else all(arr[i]*arr[j] <= result[0]*result[1] for i in range(len(arr)) for j in range(i+1, len(arr)))",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 417,
    "function_code": "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] ",
    "postconditions": {
      "naive": {
        "postcondition_string": "all(len(tuple_) > 1 and tuple_[0] in [t[0] for t in Input] for tuple_ in result)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(result[i][0] == list(Input)[j][0] for i, j in [(i, next((k for k, x in enumerate(Input) if x[0] == result[i][0]), None)) for i in range(len(result))]) and all(all(y in [z for t in Input if t[0] == result[i][0] for z in t[1:]] for y in result[i][1:]) for i in range(len(result)))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "`all(len(result[i][1:]) == sum(1 for elem in Input if elem[0] == result[i][0]) for i in range(len(result)))`",
        "is_testable": false
      }
    }
  },
  {
    "task_id": 418,
    "function_code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == max(lst)",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "all(result >= x for x in lst) and result in lst",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert all(result >= x for x in lst)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 419,
    "function_code": "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum",
    "postconditions": {
      "naive": {
        "postcondition_string": "`result == sum([round(i) for i in list1]) * len(list1)`",
        "is_testable": false
      },
      "few_shot": {
        "postcondition_string": "result == sum(list(map(round,list1))) * len(list1)",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == sum(round(i) for i in list1) * len(list1)",
        "is_testable": true
      }
    }
  },
  {
    "task_id": 420,
    "function_code": "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum",
    "postconditions": {
      "naive": {
        "postcondition_string": "result == sum((2*i)*(2*i)*(2*i) for i in range(1, n + 1))",
        "is_testable": true
      },
      "few_shot": {
        "postcondition_string": "result == sum((2*i)**3 for i in range(1, n + 1))",
        "is_testable": true
      },
      "cot": {
        "postcondition_string": "assert result == 8 * (n * (n + 1) // 2)**2",
        "is_testable": true
      }
    }
  }
]