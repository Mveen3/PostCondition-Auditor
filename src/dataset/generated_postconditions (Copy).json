[
  {
    "task_id": 625,
    "function_code": "def swap_List(newList): \n    size = len(newList) \n    temp = newList[0] \n    newList[0] = newList[size - 1] \n    newList[size - 1] = temp   \n    return newList ",
    "generated_postconditions": {
      "naive": "assert (len(result) == len(newList) and \\\n        result[0] == newList[len(newList)-1] and \\\n        result[len(result)-1] == newList[0] and \\\n        all(result[i] == newList[i] for i in range(1, len(newList) - 1)))",
      "few_shot": "assert (len(newList) == 1 and result == newList) or (len(newList) >= 2 and len(result) == len(newList) and result[0] == newList[len(newList) - 1] and result[len(newList) - 1] == newList[0] and all(result[i] == newList[i] for i in range(1, len(newList) - 1)))",
      "chain_of_thought": "assert result is newList and \\\n       len(result) == len(newList) and \\\n       (len(newList) <= 1 or \\\n        (result[0] == newList[len(newList) - 1] and \\\n         result[len(result) - 1] == newList[0] and \\\n         all(result[i] == newList[i] for i in range(1, len(newList) - 1))))"
    }
  },
  {
    "task_id": 103,
    "function_code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
    "generated_postconditions": {
      "naive": "assert result >= 0 and isinstance(result, int)",
      "few_shot": "assert \\\n    ((m >= n or n == 0) and result == 0) \\\n    or \\\n    (m == 0 and result == 1) \\\n    or \\\n    ((m > 0 and m < n and n > 0) and isinstance(result, int) and result > 0)",
      "chain_of_thought": "assert isinstance(result, int) and result >= 0 and \\\n       ( (m >= n or n == 0) and result == 0 ) or \\\n       ( (n > 0 and m == 0) and result == 1 ) or \\\n       ( (0 < m < n) and result > 0 )"
    }
  },
  {
    "task_id": 18,
    "function_code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) ",
    "generated_postconditions": {
      "naive": "result == ''.join([c for c in string if c not in second_string])",
      "few_shot": "assert result == \"\".join(c for c in string if c not in set(second_string))",
      "chain_of_thought": "assert result == ''.join([c for c in string if c not in second_string])"
    }
  },
  {
    "task_id": 757,
    "function_code": "def count_reverse_pairs(test_list):\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \n  return res",
    "generated_postconditions": {
      "naive": "assert result == sum(1 for idx in range(len(test_list)) for idxn in range(idx, len(test_list)) if test_list[idxn] == ''.join(reversed(test_list[idx])))",
      "few_shot": "assert result == sum(1 for idx in range(len(test_list)) for idxn in range(idx, len(test_list)) if test_list[idxn] == test_list[idx][::-1])",
      "chain_of_thought": "assert result == sum(1 for i in range(len(test_list)) for j in range(i, len(test_list)) if test_list[j] == test_list[i][::-1])"
    }
  },
  {
    "task_id": 267,
    "function_code": "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) ",
    "generated_postconditions": {
      "naive": "assert result == sum((2 * k - 1)**2 for k in range(1, n + 1))",
      "few_shot": "assert result == sum((2 * i + 1)**2 for i in range(n))",
      "chain_of_thought": "assert result == sum((2*i - 1)**2 for i in range(1, n + 1))"
    }
  },
  {
    "task_id": 249,
    "function_code": "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result",
    "generated_postconditions": {
      "naive": "assert all((result.count(x) == array_nums2.count(x) if x in array_nums1 else result.count(x) == 0) for x in set(array_nums2))",
      "few_shot": "assert result == [x for x in array_nums2 if x in array_nums1]",
      "chain_of_thought": "assert isinstance(result, list) and \\\n       all(result.count(x) == array_nums2.count(x) for x in set(array_nums2) if x in array_nums1) and \\\n       all(result.count(x) == 0 for x in set(array_nums2) if x not in array_nums1)"
    }
  },
  {
    "task_id": 235,
    "function_code": "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) ",
    "generated_postconditions": {
      "naive": "assert all(((result >> k) & 1 == 1 if k % 2 == 0 else (result >> k) & 1 == (n >> k) & 1) for k in range(n.bit_length()))",
      "few_shot": "assert all(((result >> k) & 1) == (((n >> k) & 1) or (k % 2 == 1 and k < n.bit_length())) for k in range(n.bit_length()))",
      "chain_of_thought": "assert all((((n >> j) & 1) == 1 or (j % 2 == 1 and j < n.bit_length())) == (((result >> j) & 1) == 1) for j in range(max(n.bit_length(), result.bit_length())))"
    }
  },
  {
    "task_id": 123,
    "function_code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)",
    "generated_postconditions": {
      "naive": "assert result == sum(set().union(*[(_num, sum(f for f in range(1, _num) if _num % f == 0)) for _num in range(2, limit + 1) if _num == sum(f_prime for f_prime in range(1, sum(f for f in range(1, _num) if _num % f == 0)) if sum(f for f in range(1, _num) if _num % f == 0) % f_prime == 0) and _num != sum(f for f in range(1, _num) if _num % f == 0)]))",
      "few_shot": "assert (not isinstance(limit, int) and result == \"Input is not an integer!\") or \\\n       (isinstance(limit, int) and limit < 1 and result == \"Input must be bigger than 0!\") or \\\n       (isinstance(limit, int) and limit >= 1 and \\\n        (lambda _sum_proper_divisors: \\\n            sum(\n                ({num_candidate for num_candidate in range(2, limit + 1)\n                  if num_candidate == _sum_proper_divisors(_sum_proper_divisors(num_candidate)) and \\\n                     num_candidate != _sum_proper_divisors(num_candidate)} |\n                 {_sum_proper_divisors(num_candidate) for num_candidate in range(2, limit + 1)\n                  if num_candidate == _sum_proper_divisors(_sum_proper_divisors(num_candidate)) and \\\n                     num_candidate != _sum_proper_divisors(num_candidate)}\n                )\n            )\n        )(lambda n: sum(f for f in range(1, n) if n % f == 0) if n > 1 else 0) == result \\\n       )",
      "chain_of_thought": "assert (not isinstance(limit, int) and result == \"Input is not an integer!\") or \\\n       (isinstance(limit, int) and ( \\\n           (limit < 1 and result == \"Input must be bigger than 0!\") or \\\n           (limit >= 1 and isinstance(result, int) and \\\n               result == sum(set(n for n in range(2, limit + 1) if \\\n                                  (sum(d_first for d_first in range(1, n) if n % d_first == 0) != n and \\\n                                   sum(d_second for d_second in range(1, (sum(d_outer for d_outer in range(1, n) if n % d_outer == 0))) if (sum(d_outer for d_outer in range(1, n) if n % d_outer == 0)) % d_second == 0) == n) \\\n                                 ) \\\n                             ) \\\n           ) \\\n       ))"
    }
  },
  {
    "task_id": 755,
    "function_code": "def second_smallest(numbers):\n  unique_numbers = list(set(numbers))\n  unique_numbers.sort()\n  if len(unique_numbers) < 2:\n    return None\n  else:\n    return unique_numbers[1]",
    "generated_postconditions": {
      "naive": "assert (result is None and len(set(numbers)) < 2) or (result is not None and len(set(numbers)) >= 2 and result == sorted(set(numbers))[1])",
      "few_shot": "assert (result is None and len(set(numbers)) < 2) or (result is not None and result == sorted(list(set(numbers)))[1])",
      "chain_of_thought": "assert (result is None and len(sorted(list(set(numbers)))) < 2) or \\\n       (result is not None and result == sorted(list(set(numbers)))[1])"
    }
  },
  {
    "task_id": 98,
    "function_code": "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) ",
    "generated_postconditions": {
      "naive": "assert len(numbers) == 0 or result == (1 if not numbers else __import__('math').prod(numbers)) / len(numbers)",
      "few_shot": "assert len(numbers) > 0 and result * len(numbers) == (1 if not numbers else __import__('math').prod(numbers))",
      "chain_of_thought": "assert len(numbers) > 0 and isinstance(result, float) and (not any(x == 0 for x in numbers) or result == 0.0)"
    }
  },
  {
    "task_id": 722,
    "function_code": "def filter_data(students,h,w):\n    result = {k: s for k, s in students.items() if s[0] >=h and s[1] >=w}\n    return result    ",
    "generated_postconditions": {
      "naive": "assert result == {k: s for k, s in students.items() if s[0] >= h and s[1] >= w}",
      "few_shot": "assert result.keys() == {k for k, s in students.items() if s[0] >= h and s[1] >= w} and all(result[k] == students[k] for k in result.keys())",
      "chain_of_thought": "assert result == {k: s for k, s in students.items() if s[0] >= h and s[1] >= w}"
    }
  },
  {
    "task_id": 572,
    "function_code": "def two_unique_nums(nums):\n  return [i for i in nums if nums.count(i)==1]",
    "generated_postconditions": {
      "naive": "assert result == [i for i in nums if nums.count(i) == 1]",
      "few_shot": "assert all(nums.count(x) == 1 for x in result) and all(x in result for x in nums if nums.count(x) == 1)",
      "chain_of_thought": "assert result == [x for x in nums if nums.count(x) == 1]"
    }
  },
  {
    "task_id": 90,
    "function_code": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max",
    "generated_postconditions": {
      "naive": "assert result == max(len(word) for word in list1)",
      "few_shot": "assert result == max(len(word) for word in list1)",
      "chain_of_thought": "assert result == max(len(s) for s in list1)"
    }
  },
  {
    "task_id": 596,
    "function_code": "import sys \ndef tuple_size(tuple_list):\n  return (sys.getsizeof(tuple_list)) ",
    "generated_postconditions": {
      "naive": "assert isinstance(result, int) and result > 0",
      "few_shot": "assert isinstance(result, int) and result > len(tuple_list)",
      "chain_of_thought": "assert isinstance(result, int) and result > len(tuple_list)"
    }
  },
  {
    "task_id": 428,
    "function_code": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list",
    "generated_postconditions": {
      "naive": "assert result == sorted(my_list)",
      "few_shot": "assert all(result[i] <= result[i+1] for i in range(len(result) - 1)) and sorted(result) == sorted(my_list)",
      "chain_of_thought": "assert len(result) == len(my_list) and result == sorted(my_list)"
    }
  },
  {
    "task_id": 57,
    "function_code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num ",
    "generated_postconditions": {
      "naive": "assert result == int(\"\".join([str(d) for d in sorted(arr, reverse=True)]))",
      "few_shot": "assert result == int(\"\".join(str(d) for d in sorted(arr, reverse=True)))",
      "chain_of_thought": "assert result == int(''.join(map(str, arr)))"
    }
  },
  {
    "task_id": 56,
    "function_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  ",
    "generated_postconditions": {
      "naive": "assert result == (2 * (0 if n <= 0 else int(str(n)[::-1])) == n + 1)",
      "few_shot": "assert result == (2 * (0 if n <= 0 else int(str(n)[::-1])) == n + 1)",
      "chain_of_thought": "assert result == (2 * (0 if n <= 0 else int(str(n)[::-1])) == n + 1)"
    }
  },
  {
    "task_id": 93,
    "function_code": "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)",
    "generated_postconditions": {
      "naive": "assert result == a ** b",
      "few_shot": "assert result == a ** b",
      "chain_of_thought": "assert result == a**b"
    }
  },
  {
    "task_id": 232,
    "function_code": "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest",
    "generated_postconditions": {
      "naive": "assert len(result) == min(n, len(list1)) and sorted(result) == sorted(sorted(list1, reverse=True)[:min(n, len(list1))])",
      "few_shot": "assert sorted(result) == sorted(sorted(list1, reverse=True)[:min(n, len(list1))])",
      "chain_of_thought": "assert result == sorted(list1, reverse=True)[:n]"
    }
  },
  {
    "task_id": 242,
    "function_code": "def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total",
    "generated_postconditions": {
      "naive": "assert result == len(str1)",
      "few_shot": "assert result == len(str1)",
      "chain_of_thought": "assert result == len(str1)"
    }
  },
  {
    "task_id": 474,
    "function_code": "def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2",
    "generated_postconditions": {
      "naive": "assert result == str1.replace(ch, newch)",
      "few_shot": "assert (ch != '' and result == newch.join(str1.split(ch))) or \\\n       (ch == '' and ((len(str1) == 0 and result == newch) or \\\n                      (len(str1) > 0 and result == newch + newch.join(list(str1)) + newch)))",
      "chain_of_thought": "assert isinstance(result, str) and (len(result) == len(str1) - str1.count(ch) * len(ch) + str1.count(ch) * len(newch))"
    }
  },
  {
    "task_id": 603,
    "function_code": "def get_ludic(n):\n\tludics = []\n\tfor i in range(1, n + 1):\n\t\tludics.append(i)\n\tindex = 1\n\twhile(index != len(ludics)):\n\t\tfirst_ludic = ludics[index]\n\t\tremove_index = index + first_ludic\n\t\twhile(remove_index < len(ludics)):\n\t\t\tludics.remove(ludics[remove_index])\n\t\t\tremove_index = remove_index + first_ludic - 1\n\t\tindex += 1\n\treturn ludics",
    "generated_postconditions": {
      "naive": "assert result[0] == 1 and all(1 <= x <= n for x in result) and result == sorted(result)",
      "few_shot": "Failed to extract postcondition",
      "chain_of_thought": "assert (n == 0 and result == []) or \\\n       (n >= 1 and \\\n        isinstance(result, list) and \\\n        all(isinstance(x, int) for x in result) and \\\n        all(1 <= x <= n for x in result) and \\\n        all(result[i] < result[i+1] for i in range(len(result) - 1)) and \\\n        (result[0] == 1) and \\\n        (lambda N: [y for i, y in enumerate((lambda numbers: [numbers.pop(idx) for _ in range(N // val) for idx in sorted([j + val for j in range(i + val, len(numbers), val)], reverse=True) if j + val < len(numbers) and numbers[idx] is not None])[0] if N >= 1 and (val := numbers[i]) else []])])(n) == result)"
    }
  },
  {
    "task_id": 19,
    "function_code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     ",
    "generated_postconditions": {
      "naive": "assert result == (len(arraynums) != len(set(arraynums)))",
      "few_shot": "assert result == (len(arraynums) != len(set(arraynums)))",
      "chain_of_thought": "assert result == (len(arraynums) != len(set(arraynums)))"
    }
  },
  {
    "task_id": 581,
    "function_code": "def surface_Area(b,s): \n    return 2 * b * s + pow(b,2) ",
    "generated_postconditions": {
      "naive": "assert result == 2 * b * s + pow(b,2)",
      "few_shot": "assert result == 2 * b * s + b**2",
      "chain_of_thought": "assert result == 2 * b * s + pow(b, 2)"
    }
  },
  {
    "task_id": 171,
    "function_code": "import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter",
    "generated_postconditions": {
      "naive": "assert result == 5 * a",
      "few_shot": "assert result == 5 * a",
      "chain_of_thought": "assert result == 5 * a"
    }
  },
  {
    "task_id": 744,
    "function_code": "def check_none(test_tup):\n  res = any(map(lambda ele: ele is None, test_tup))\n  return res ",
    "generated_postconditions": {
      "naive": "assert result == any(map(lambda ele: ele is None, test_tup))",
      "few_shot": "assert result == any(ele is None for ele in test_tup)",
      "chain_of_thought": "assert result == any(ele is None for ele in test_tup)"
    }
  },
  {
    "task_id": 630,
    "function_code": "def adjac(ele, sub = []): \n  if not ele: \n     yield sub \n  else: \n     yield from [idx for j in range(ele[0] - 1, ele[0] + 2) \n                for idx in adjac(ele[1:], sub + [j])] \ndef get_coordinates(test_tup):\n  return list(adjac(test_tup))",
    "generated_postconditions": {
      "naive": "assert (len(result) == 3 ** len(test_tup) and\n        all(isinstance(coord, list) for coord in result) and\n        all(len(coord) == len(test_tup) for coord in result) and\n        all(test_tup[i] - 1 <= coord[i] <= test_tup[i] + 1\n            for coord in result\n            for i in range(len(test_tup))))",
      "few_shot": "assert len(result) == 3**len(test_tup) and \\\n       all(isinstance(coord, list) and \\\n           len(coord) == len(test_tup) and \\\n           all(abs(coord[i] - test_tup[i]) <= 1 \\\n               for i in range(len(test_tup))) \\\n           for coord in result)",
      "chain_of_thought": "assert isinstance(result, list) and \\\n       len(result) == 3 ** len(test_tup) and \\\n       all(isinstance(coord, list) and \\\n           len(coord) == len(test_tup) and \\\n           all(isinstance(val, int) for val in coord) and \\\n           all(abs(coord[i] - test_tup[i]) <= 1 for i in range(len(test_tup))) \\\n           for coord in result)"
    }
  },
  {
    "task_id": 737,
    "function_code": "import re \nregex = '^[aeiouAEIOU][A-Za-z0-9_]*'\ndef check_str(string): \n\treturn re.search(regex, string)",
    "generated_postconditions": {
      "naive": "assert bool(result) == (len(string) > 0 and string[0].lower() in {'a', 'e', 'i', 'o', 'u'})",
      "few_shot": "assert (len(string) > 0 and string[0].lower() in 'aeiou') == (result is not None)",
      "chain_of_thought": "assert (result is not None) == (len(string) > 0 and string[0].lower() in 'aeiou')"
    }
  },
  {
    "task_id": 426,
    "function_code": "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums",
    "generated_postconditions": {
      "naive": "assert all(x % 2 != 0 for x in result) and len(result) == sum(1 for x in nums if x % 2 != 0)",
      "few_shot": "assert all(x % 2 != 0 for x in result) and len(result) == sum(1 for x in nums if x % 2 != 0) and all(result[i] == ([y for y in nums if y % 2 != 0])[i] for i in range(len(result)))",
      "chain_of_thought": "assert result == [x for x in nums if x % 2 != 0]"
    }
  },
  {
    "task_id": 233,
    "function_code": "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface",
    "generated_postconditions": {
      "naive": "assert result == 2 * 3.1415 * r * h",
      "few_shot": "assert result == 2 * 3.1415 * r * h",
      "chain_of_thought": "assert abs(result - (2 * 3.1415 * r * h)) < 1e-9"
    }
  },
  {
    "task_id": 441,
    "function_code": "def surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea",
    "generated_postconditions": {
      "naive": "assert result == 6 * l * l",
      "few_shot": "assert result == 6 * l * l",
      "chain_of_thought": "assert result == 6 * l * l"
    }
  },
  {
    "task_id": 595,
    "function_code": "def min_Swaps(str1,str2) : \n    count = 0\n    for i in range(len(str1)) :  \n        if str1[i] != str2[i] : \n            count += 1\n    if count % 2 == 0 : \n        return (count // 2) \n    else : \n        return (\"Not Possible\") ",
    "generated_postconditions": {
      "naive": "assert (sum(1 for i in range(len(str1)) if str1[i] != str2[i]) % 2 == 0 and result == sum(1 for i in range(len(str1)) if str1[i] != str2[i]) // 2) or (sum(1 for i in range(len(str1)) if str1[i] != str2[i]) % 2 != 0 and result == \"Not Possible\")",
      "few_shot": "assert ((sum(1 for i in range(len(str1)) if str1[i] != str2[i])) % 2 == 0 and result == (sum(1 for i in range(len(str1)) if str1[i] != str2[i])) // 2) or ((sum(1 for i in range(len(str1)) if str1[i] != str2[i])) % 2 != 0 and result == \"Not Possible\")",
      "chain_of_thought": "assert result == (sum(1 for i in range(len(str1)) if str1[i] != str2[i]) // 2 if sum(1 for i in range(len(str1)) if str1[i] != str2[i]) % 2 == 0 else \"Not Possible\")"
    }
  },
  {
    "task_id": 269,
    "function_code": "def ascii_value(k):\n  ch=k\n  return ord(ch)",
    "generated_postconditions": {
      "naive": "assert result == ord(k)",
      "few_shot": "assert result == ord(k)",
      "chain_of_thought": "assert isinstance(result, int) and result == ord(k)"
    }
  },
  {
    "task_id": 797,
    "function_code": "def sum_odd(n): \n    terms = (n + 1)//2\n    sum1 = terms * terms \n    return sum1  \ndef sum_in_range(l,r): \n    return sum_odd(r) - sum_odd(l - 1)",
    "generated_postconditions": {
      "naive": "assert result == sum(i for i in range(l, r + 1) if i % 2 != 0 and i >= 1)",
      "few_shot": "assert result == (((r + 1) // 2) ** 2) - ((l // 2) ** 2)",
      "chain_of_thought": "assert result == sum(x for x in range(l, r + 1) if x % 2 != 0)"
    }
  },
  {
    "task_id": 6,
    "function_code": "def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)",
    "generated_postconditions": {
      "naive": "assert result == ((a ^ b) > 0 and ((a ^ b) & ((a ^ b) - 1)) == 0)",
      "few_shot": "assert result == ((a ^ b) > 0 and ((a ^ b) & ((a ^ b) - 1)) == 0)",
      "chain_of_thought": "assert result == ((a ^ b > 0) and (bin(a ^ b).count('1') == 1))"
    }
  },
  {
    "task_id": 767,
    "function_code": "def get_pairs_count(arr, sum):\n    count = 0  \n    for i in range(len(arr)):\n        for j in range(i + 1,len(arr)):\n            if arr[i] + arr[j] == sum:\n                count += 1\n    return count",
    "generated_postconditions": {
      "naive": "assert result == sum(1 for i in range(len(arr)) for j in range(i + 1, len(arr)) if arr[i] + arr[j] == sum)",
      "few_shot": "assert result == sum(1 for i in range(len(arr)) for j in range(i + 1, len(arr)) if arr[i] + arr[j] == sum)",
      "chain_of_thought": "assert result == sum(1 for i in range(len(arr)) for j in range(i + 1, len(arr)) if arr[i] + arr[j] == sum)"
    }
  },
  {
    "task_id": 794,
    "function_code": "import re\ndef text_starta_endb(text):\n        patterns = 'a.*?b$'\n        return re.search(patterns,  text)",
    "generated_postconditions": {
      "naive": "assert (result is not None) == (text.endswith('b') and ('a' in text) and (text.find('a') < len(text) - 1))",
      "few_shot": "assert (result is None and (not text.endswith('b') or text.find('a') == -1)) or \\\n       (result is not None and text.endswith('b') and text.find('a') != -1 and \\\n        result.group(0) == text[text.find('a'):])",
      "chain_of_thought": "assert (result is not None and \\\n              len(text) > 0 and \\\n              text[-1] == 'b' and \\\n              'a' in text and \\\n              result.group(0)[0] == 'a' and \\\n              result.group(0)[-1] == 'b' and \\\n              result.end() == len(text)) or \\\n             (result is None and \\\n              not (len(text) > 0 and text[-1] == 'b' and 'a' in text))"
    }
  },
  {
    "task_id": 133,
    "function_code": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)",
    "generated_postconditions": {
      "naive": "assert result == sum(n for n in nums if n < 0)",
      "few_shot": "assert result == sum(x for x in nums if x < 0)",
      "chain_of_thought": "assert result == sum(x for x in nums if x < 0)"
    }
  },
  {
    "task_id": 735,
    "function_code": "def set_middle_bits(n):  \n    n |= n >> 1; \n    n |= n >> 2; \n    n |= n >> 4; \n    n |= n >> 8; \n    n |= n >> 16;  \n    return (n >> 1) ^ 1\ndef toggle_middle_bits(n): \n    if (n == 1): \n        return 1\n    return n ^ set_middle_bits(n) ",
    "generated_postconditions": {
      "naive": "assert (result & 1 == n & 1) and \\\n       ((n == 1 and result == n) or \\\n        (n > 1 and \\\n         ((result >> (n.bit_length() - 1)) & 1) == ((n >> (n.bit_length() - 1)) & 1) and \\\n         all((((result >> i) & 1) != ((n >> i) & 1)) for i in range(1, n.bit_length() - 1))))",
      "few_shot": "assert (n == 1 and result == 1) or \\\n       (n > 1 and \\\n        ((n >> (n.bit_length() - 1)) & 1) == ((result >> (n.bit_length() - 1)) & 1) and \\\n        ((n >> 0) & 1) == ((result >> 0) & 1) and \\\n        all(((n >> i) & 1) != ((result >> i) & 1) for i in range(1, n.bit_length() - 1)) \\\n       )",
      "chain_of_thought": "assert (result == 1 if n == 1 else result == (n ^ (1 if n <= 1 else sum(1 << i for i in range(1, n.bit_length() - 1)))))"
    }
  },
  {
    "task_id": 307,
    "function_code": "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon",
    "generated_postconditions": {
      "naive": "assert len(result) == len(tuplex) and all(result[i] == tuplex[i] for i in range(len(tuplex)) if i != m) and result[m] == tuplex[m] + [n]",
      "few_shot": "assert len(result) == len(tuplex) and all(result[i] == tuplex[i] for i in range(len(tuplex)) if i != m) and result[m] == tuplex[m] + [n]",
      "chain_of_thought": "assert (result is not tuplex and \\\n        len(result) == len(tuplex) and \\\n        len(result[m]) == len(tuplex[m]) + 1 and \\\n        result[m][-1] == n and \\\n        result[m][:-1] == tuplex[m] and \\\n        all(result[i] == tuplex[i] for i in range(len(tuplex)) if i != m))"
    }
  },
  {
    "task_id": 131,
    "function_code": "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string",
    "generated_postconditions": {
      "naive": "assert (\n    len(result) == len(str1)\n    and all(result[i] == str1[i] for i in range(len(str1)) if str1[i] not in \"aeiouAEIOU\")\n    and (\n        [char for char in result if char in \"aeiouAEIOU\"]\n        == [char for char in str1 if char in \"aeiouAEIOU\"][::-1]\n    )\n)",
      "few_shot": "assert (\n    len(result) == len(str1) and\n    all(result[i] == str1[i] for i in range(len(str1)) if str1[i] not in \"aeiouAEIOU\") and\n    [char for char in result if char in \"aeiouAEIOU\"] == [char for char in str1 if char in \"aeiouAEIOU\"][::-1]\n)",
      "chain_of_thought": "assert (len(result) == len(str1) and\n        all(result[i] == str1[i] for i in range(len(str1)) if str1[i] not in \"aeiouAEIOU\") and\n        [char for char in result if char in \"aeiouAEIOU\"] == [char for char in str1 if char in \"aeiouAEIOU\"][::-1])"
    }
  },
  {
    "task_id": 230,
    "function_code": "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2",
    "generated_postconditions": {
      "naive": "assert len(result) == len(str1) and all(result[i] == char if str1[i] == ' ' else result[i] == str1[i] for i in range(len(str1)))",
      "few_shot": "assert len(result) == len(str1) and all(result[i] == (char if str1[i] == ' ' else str1[i]) for i in range(len(str1)))",
      "chain_of_thought": "assert (\n    len(result) == len(str1) + sum(1 for c_str1 in str1 if c_str1 == ' ') * (len(char) - 1)\n    and\n    all(\n        (sum(1 for c_res_iter in result if c_res_iter == c_check) ==\n            (sum(1 for c_str1_iter in str1 if c_str1_iter == ' ') if char == ' ' else 0)\n            if c_check == ' ' else\n            (\n                (sum(1 for c_str1_iter in str1 if c_str1_iter == c_check) + sum(1 for c_str1_iter in str1 if c_str1_iter == ' '))\n                if c_check == char and char != ' ' else\n                sum(1 for c_str1_iter in str1 if c_str1_iter == c_check)\n            )\n        )\n        for c_check in list(set(list(str1) + list(char) + [' '])) # Check all relevant unique characters including space\n    )\n)"
    }
  },
  {
    "task_id": 770,
    "function_code": "def odd_num_sum(n) : \n    j = 0\n    sm = 0\n    for i in range(1,n + 1) : \n        j = (2*i-1) \n        sm = sm + (j*j*j*j)   \n    return sm ",
    "generated_postconditions": {
      "naive": "assert result == sum(((2*i - 1)**4) for i in range(1, n + 1))",
      "few_shot": "assert result == sum(((2 * i - 1)**4 for i in range(1, n + 1)))",
      "chain_of_thought": "assert result == sum(((2*k - 1)**4) for k in range(1, n + 1))"
    }
  },
  {
    "task_id": 305,
    "function_code": "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()",
    "generated_postconditions": {
      "naive": "assert isinstance(result, tuple) and len(result) == 2 and all(isinstance(x, str) for x in result) and all(x.startswith('P') for x in result)",
      "few_shot": "assert result == next((m.groups() for m in (re.match(r\"(P\\w+)\\W(P\\w+)\", w) for w in words) if m is not None), None)",
      "chain_of_thought": "assert (result is None) or \\\n       (isinstance(result, tuple) and \\\n        len(result) == 2 and \\\n        isinstance(result[0], str) and \\\n        isinstance(result[1], str) and \\\n        result[0].startswith('P') and \\\n        len(result[0]) >= 2 and \\\n        all(c.isalnum() or c == '_' for c in result[0][1:]) and \\\n        result[1].startswith('P') and \\\n        len(result[1]) >= 2 and \\\n        all(c.isalnum() or c == '_' for c in result[1][1:]))"
    }
  },
  {
    "task_id": 404,
    "function_code": "def minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b ",
    "generated_postconditions": {
      "naive": "assert result == min(a, b)",
      "few_shot": "assert (result == a or result == b) and result <= a and result <= b",
      "chain_of_thought": "assert (result == a or result == b) and result <= a and result <= b"
    }
  },
  {
    "task_id": 95,
    "function_code": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength ",
    "generated_postconditions": {
      "naive": "assert any(result == len(sublist) for sublist in lst) and all(result <= len(sublist) for sublist in lst)",
      "few_shot": "assert result == min(len(x) for x in lst)",
      "chain_of_thought": "assert all(len(sublist) >= result for sublist in lst) and any(len(sublist) == result for sublist in lst)"
    }
  },
  {
    "task_id": 391,
    "function_code": "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result",
    "generated_postconditions": {
      "naive": "assert result == [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]",
      "few_shot": "assert len(result) == min(len(l1), len(l2), len(l3)) and all(result[i] == {l1[i]: {l2[i]: l3[i]}} for i in range(len(result)))",
      "chain_of_thought": "assert (\n    len(result) == min(len(l1), len(l2), len(l3)) and\n    all(\n        isinstance(item, dict) and\n        len(item) == 1 and\n        list(item.keys())[0] == x_val and\n        isinstance(list(item.values())[0], dict) and\n        len(list(item.values())[0]) == 1 and\n        list(list(item.values())[0].keys())[0] == y_val and\n        list(list(item.values())[0].values())[0] == z_val\n        for item, x_val, y_val, z_val in zip(result, l1, l2, l3)\n    )\n)"
    }
  },
  {
    "task_id": 309,
    "function_code": "def maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b ",
    "generated_postconditions": {
      "naive": "assert result == max(a, b)",
      "few_shot": "assert result in (a, b) and result >= a and result >= b",
      "chain_of_thought": "assert result == max(a, b)"
    }
  },
  {
    "task_id": 604,
    "function_code": "def reverse_words(s):\n        return ' '.join(reversed(s.split()))",
    "generated_postconditions": {
      "naive": "result.split() == list(reversed(s.split()))",
      "few_shot": "assert result.split() == s.split()[::-1]",
      "chain_of_thought": "assert list(result.split()) == list(reversed(s.split()))"
    }
  },
  {
    "task_id": 261,
    "function_code": "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ",
    "generated_postconditions": {
      "naive": "assert isinstance(result, tuple) and \\\n       len(result) == min(len(test_tup1), len(test_tup2)) and \\\n       all(result[i] == test_tup1[i] // test_tup2[i] for i in range(len(result)))",
      "few_shot": "assert len(result) == min(len(test_tup1), len(test_tup2)) and all(result[i] == test_tup1[i] // test_tup2[i] for i in range(len(result)))",
      "chain_of_thought": "assert isinstance(result, tuple) and \\\n       len(result) == min(len(test_tup1), len(test_tup2)) and \\\n       all(result[i] == test_tup1[i] // test_tup2[i] for i in range(len(result)))"
    }
  }
]